<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Онлайн тюнер для барабана — фундаментальная частота</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--glass: rgba(255,255,255,0.04)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#061022 0%, #07162b 100%);color:#E6EEF3;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:980px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.7)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between; flex-wrap: wrap; margin-top: 200px}
    .title{font-size:20px;font-weight:600}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);border:none;color:#022;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .display{display:flex;gap:12px;margin-top:12px;align-items:center}
    .panel{background:var(--card);padding:12px;border-radius:10px;flex:1;min-height:100px}
    .freq{font-size:44px;font-weight:700;letter-spacing:0.6px}
    .sub{color:var(--muted);font-size:14px}
    canvas{width:100%;height:120px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));border-radius:8px}
    .small{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:12px}
    select,input[type=range]{background:transparent;color:inherit;border-radius:8px;padding:6px;border:1px solid rgba(255,255,255,0.04)}
    footer{margin-top:10px;color:var(--muted);font-size:13px}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}
    @media(max-width:640px){.display{flex-direction:column}.row{flex-direction:column}}
  </style>
</head>
<body>
  <div class="card">
    <header>
      <div>
        <div class="title">Онлайн тюнер для барабана — определение фундаментальной частоты</div>
        <div class="small">Использует микрофон устройства; алгоритм автокорреляции/YIN-подобный для низких частот</div>
      </div>
      <div class="controls">
        <button id="startBtn">Запустить</button>
        <button id="stopBtn" class="secondary" disabled>Остановить</button>
      </div>
    </header>

    <div class="display">
      <div class="panel" style="flex:0 0 320px;">
        <div class="sub">Частота</div>
        <div id="freq" class="freq">— Hz</div>
        <div id="note" class="sub">—</div>
        <div class="hint">Hold/strike барабана рядом с микрофоном для точного измерения. Лучше в тихом помещении.</div>
      </div>

      <div style="flex:1">
        <div class="row">
          <div class="panel">
            <div class="sub">Осциллограмма</div>
            <canvas id="waveCanvas" width="800" height="120"></canvas>
          </div>
        </div>
        <div style="height:12px"></div>
        <div class="row">
          <div class="panel">
            <div class="sub">Спектр (FFT)</div>
            <canvas id="specCanvas" width="800" height="120"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap">
      <label class="small">Чувствительность (порог детекции): <input id="thresh" type="range" min="0" max="1" step="0.01" value="0.15"></label>
      <label class="small">Сглаживание (мс): <input id="smoothing" type="range" min="0" max="300" step="10" value="60"></label>
      <label class="small">Показывать ноту: <input id="showNote" type="checkbox" checked></label>
    </div>

    <footer>
      Совет: для низких частот (барабаны) лучше использовать большую буферизацию. Если тюнер "прыгает" — увеличьте сглаживание.
    </footer>
  </div>

<script>
// Простая реализация обнаружения фундаментальной частоты на основе автокорреляции
let audioCtx, analyzer, mediaStreamSource, rafId;
let running = false;
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const freqEl = document.getElementById('freq');
const noteEl = document.getElementById('note');
const waveCanvas = document.getElementById('waveCanvas');
const specCanvas = document.getElementById('specCanvas');
const threshInput = document.getElementById('thresh');
const smoothingInput = document.getElementById('smoothing');
const showNoteInput = document.getElementById('showNote');
const waveCtx = waveCanvas.getContext('2d');
const specCtx = specCanvas.getContext('2d');

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', stop);

async function start(){
  if(running) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true},video:false});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyzer = audioCtx.createAnalyser();
    analyzer.fftSize = 32768; // большой размер для хорошего разрешения по низким частотам
    analyzer.smoothingTimeConstant = 0.0;
    mediaStreamSource = audioCtx.createMediaStreamSource(stream);
    mediaStreamSource.connect(analyzer);
    running = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    tick();
  }catch(err){
    alert('Не удалось получить доступ к микрофону: ' + err.message);
  }
}

function stop(){
  if(!running) return;
  running = false;
  if(rafId) cancelAnimationFrame(rafId);
  if(mediaStreamSource && mediaStreamSource.mediaStream){
    mediaStreamSource.mediaStream.getTracks().forEach(t=>t.stop());
  }
  if(audioCtx) audioCtx.close();
  startBtn.disabled = false;
  stopBtn.disabled = true;
  freqEl.textContent = '— Hz';
  noteEl.textContent = '—';
}

function tick(){
  const bufferLen = analyzer.fftSize;
  const timeData = new Float32Array(bufferLen);
  analyzer.getFloatTimeDomainData(timeData);

  drawWave(timeData);
  drawSpectrum();

  const threshold = parseFloat(threshInput.value);
  const pitch = autoCorrelate(timeData, audioCtx.sampleRate, threshold);
  if(pitch !== -1){
    const smoothMs = parseFloat(smoothingInput.value);
    // простое экспоненциальное сглаживание
    if(!tick._last) tick._last = pitch;
    const alpha = Math.exp(-1/(Math.max(1,smoothMs) * audioCtx.sampleRate/1000));
    const displayed = tick._last * alpha + pitch * (1-alpha);
    tick._last = displayed;

    freqEl.textContent = displayed.toFixed(2) + ' Hz';
    if(showNoteInput.checked){
      noteEl.textContent = noteFromFreq(displayed);
    }else noteEl.textContent = '';
  } else {
    // нет детекции
    freqEl.textContent = '— Hz';
    noteEl.textContent = '—';
  }

  rafId = requestAnimationFrame(tick);
}

function drawWave(buffer){
  const w = waveCanvas.width;
  const h = waveCanvas.height;
  waveCtx.clearRect(0,0,w,h);
  waveCtx.beginPath();
  waveCtx.lineWidth = 1.5;
  waveCtx.strokeStyle = '#70f7ff';
  const step = Math.floor(buffer.length / w);
  for(let i=0;i<w;i++){
    const idx = i*step;
    const v = buffer[idx] || 0;
    const y = (1 - (v+1)/2) * h;
    if(i===0) waveCtx.moveTo(i,y); else waveCtx.lineTo(i,y);
  }
  waveCtx.stroke();
}

function drawSpectrum(){
  const w = specCanvas.width;
  const h = specCanvas.height;
  const fftSize = 32768;
  const temp = new Float32Array(analyzer.frequencyBinCount);
  // Для спектра используем AnalyserNode
  analyzer.getFloatFrequencyData(temp);
  specCtx.clearRect(0,0,w,h);
  specCtx.beginPath();
  specCtx.lineWidth = 1.2;
  specCtx.strokeStyle = '#9be3ff';
  const step = Math.max(1, Math.floor(temp.length / w));
  for(let i=0;i<w;i++){
    const mag = temp[i*step]; // в dB
    // нормализуем примерно -140..0 dB
    const norm = (mag + 140) / 140;
    const y = h - Math.max(0, Math.min(1, norm)) * h;
    if(i===0) specCtx.moveTo(i,y); else specCtx.lineTo(i,y);
  }
  specCtx.stroke();
}

// Автокорреляция, возвращает частоту в Hz или -1 если не обнаружено
function autoCorrelate(buf, sampleRate, threshold){
  // Параметры
  const SIZE = buf.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++){ const val = buf[i]; rms += val*val; }
  rms = Math.sqrt(rms / SIZE);
  if(rms < 0.01) return -1; // тихо

  let r1 = 0, r2 = SIZE-1, th = threshold || 0.2;
  // границы для автокорреляции
  for(let i=0;i<SIZE/2;i++){
    if(Math.abs(buf[i]) < 0.0001){ r1 = i; break; }
  }
  for(let i=1;i<SIZE/2;i++){
    if(Math.abs(buf[SIZE-i]) < 0.0001){ r2 = SIZE-i; break; }
  }

  buf = buf.slice(r1, r2);
  const newSize = buf.length;
  const c = new Array(newSize).fill(0);
  for(let i=0;i<newSize;i++){
    for(let j=0;j<newSize - i;j++){
      c[i] = c[i] + buf[j]*buf[j+i];
    }
  }

  let d = 0;
  while(c[d] > c[d+1] && d < newSize-2) d++;
  let maxval = -1, maxpos = -1;
  for(let i=d;i<newSize;i++){
    if(c[i] > maxval){ maxval = c[i]; maxpos = i; }
  }
  if(maxval <= 0) return -1;

  // интерполяция параболой
  let x1 = c[maxpos-1], x2 = c[maxpos], x3 = c[maxpos+1];
  const a = (x1 + x3 - 2*x2)/2;
  const b = (x3 - x1)/2;
  let shift = 0;
  if(a) shift = -b/(2*a);
  const period = maxpos + shift;
  const freq = sampleRate / period;
  if(freq > 8000 || freq < 20) return -1;
  return freq;
}

// Простейшее преобразование частоты в ноту (показывает октаву и ближайшую ноту)
function noteFromFreq(freq){
  const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const A4 = 440;
  const semitones = 12 * Math.log2(freq / A4);
  const noteNum = Math.round(semitones) + 69; // MIDI
  const noteIndex = (noteNum + 120) % 12;
  const octave = Math.floor(noteNum / 12) - 1;
  const cents = Math.round((semitones - Math.round(semitones)) * 100);
  return noteNames[noteIndex] + octave + (cents===0? '' : ' (' + (cents>0? '+':'') + cents + '¢)');
}

</script>
</body>
</html>
